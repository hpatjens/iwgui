<html>
    <style>
        button {
            display: block;
        }

        .row {
            display: flex;
        }

        .column {
            flex: 50%;
        }

    </style>
    <script>
        let to_browser_socket = new WebSocket("ws://localhost:9001")
        let to_server_socket = new WebSocket("ws://localhost:9001")
        let uuid = #uuid
        let vdom_root = null
        let vdom = {}

        /// true when the object has to properties, otherwise false
        function is_empty(obj) {
            console.assert(obj, { errorMsg: "value must be truthly" })
            return Object.keys(obj).length === 0 && obj.constructor === Object
        }

        /// Returns the first value of the object
        function first_value(obj) {
            console.assert(obj, { errorMsg: "value must be truthly" })
            console.assert(Object.keys(obj).length > 0, { number: Object.keys(obj).length, errorMsg: "no first element available" })
            return obj[Object.keys(obj)[0]]
        }

        /// Returns the first key of the object
        function first_key(obj) {
            console.assert(obj, { errorMsg: "value must be truthly" })
            console.assert(Object.keys(obj).length > 0, { number: Object.keys(obj).length, errorMsg: "no first element available" })
            return Object.keys(obj)[0]
        }

        /// Removes the first key-value pair of the object and returns it
        function pop_first_value(obj) {
            console.assert(obj, { errorMsg: "value must be truthly" })
            var result = first_value(obj)
            delete obj[Object.keys(obj)[0]]
            return result
        }

        function pop_first_property(obj) {
            console.assert(obj, { errorMsg: "value must be truthly" })
            var key = first_key(obj)
            var value = first_value(obj)
            delete obj[Object.keys(obj)[0]]
            return [key, value]
        }

        to_browser_socket.onopen = function(e) {
            // Send the welcome message to the server to register this websocket as the one responsible for the server-browser connection
            to_browser_socket.send(JSON.stringify({
                "Welcome":{
                    "direction":"ToBrowser",
                    "uuid":uuid
                }
            }))
        }
        to_browser_socket.onmessage = function(event) {
            // This is a serialized `ServerBrowserUpdate` on the Rust side
            var server_browser_update = JSON.parse(event.data)

            // Apply changes to the browsers VDom
            for (const gui_id in server_browser_update.removed) {
                delete vdom[gui_id]
            }
            for (const gui_id in server_browser_update.updated) {
                vdom[gui_id] = server_browser_update.updated[gui_id]
            }
            for (const gui_id in server_browser_update.added) {
                vdom[gui_id] = server_browser_update.added[gui_id]
            }


            if (server_browser_update.root) {
                vdom_root = server_browser_update.root
            }
            let new_body = convert_to_dom(vdom_root, vdom)
            let body = document.body.firstChild
            if (body == null) {
                document.body.appendChild(new_body)
            } else if (body != new_body) {
                body.replaceWith(new_body)
            }
        }
        to_browser_socket.onclose = function(event) {
            if (event.wasClean) {
                console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`)
            } else {
                console.log('[close] Connection died')
            }
        }
        to_browser_socket.onerror = function(error) {
            console.log(`[error] ${error.message}`)
        }


        
        to_server_socket.onopen = function(e) {
            // Send the welcome message to the server to register this websocket as the one responsible for the browser-server connection
            to_server_socket.send(JSON.stringify({
                "Welcome":{
                    "direction":"ToServer",
                    "uuid":uuid
                }
            }))
        }
        to_server_socket.onmessage = function(event) {
            console.log("[Error] onmessage called on to_server_socket")
        }
        to_server_socket.onclose = function(event) {
            if (event.wasClean) {
                console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`)
            } else {
                console.log('[close] Connection died')
            }
        }
        to_server_socket.onerror = function(error) {
            console.log(`[error] ${error.message}`)
        }

        function convert_to_dom(gui_id, vdom) {
            // Create a new dom node
            let node = vdom[gui_id]
            let type = first_key(node)
            let create_or_update_function = ({
                "StackLayout": create_or_update_stack_layout,
                "Columns": create_or_update_columns,
                "Button": create_or_update_buttons,
                "Checkbox": create_or_update_checkbox,
                "Label": create_or_update_label,
                "Header": create_or_update_header,
            }[type])
            let dom_node = create_or_update_function(gui_id, vdom)
            if (!dom_node) {
                console.error({ errorMsg: "Unknown type of element", type: type })
                    return null
                    // TODO: Propagate failure case
            }
            return dom_node
        }
        function reuse_or_create(node, f) {
            if (node.dom_node) {
                return node.dom_node
            } else {
                node.dom_node = f()
                return node.dom_node
            }
        }
        function create_or_update_stack_layout(gui_id, vdom) {
            /* <div>{}</div> */
            let node = vdom[gui_id]
            let dom_node = reuse_or_create(node, () => {
                let dom_node = document.createElement("div")
                dom_node.id = gui_id
                return dom_node
            })

            var index = 0
            for (const child_gui_id of node.StackLayout.children) {
                let new_child = convert_to_dom(child_gui_id, vdom)
                let child = dom_node.childNodes.item(index)
                if (child == null) {
                    dom_node.appendChild(new_child)
                } else if (child != new_child) {
                    child.replaceWith(new_child)
                }
                index += 1
            }

            /*
            dom_node.innerHTML = ""
            for (const child_gui_id of node.StackLayout.children) {
                // let new_child = convert_to_dom(child_gui_id, vdom)
                // let child = document.getElementById(gui_id)
                // if (child == null) {
                //     dom_node.appendChild(new_child)
                // } else if (child != new_child) {
                //     child.replaceWith(new_child)
                // }
                let child = convert_to_dom(child_gui_id, vdom)
                dom_node.appendChild(child)
            }
            */
            // TODO: Remove children that were not hit
            return dom_node
        }
        function create_or_update_columns(gui_id, vdom) {
            // TODO: Cleanup this stuff
            /*
            <div class="row">
                <div class="column">{}</div>
                <div class="column">{}</div>
            </div>
            */
            let node = vdom[gui_id]
            let dom_node = reuse_or_create(node, () => {
                // Parent
                let columns = document.createElement("div")
                columns.id = gui_id
                columns.classList.add("row")

                // Left child
                let left = document.createElement("div")
                left.id = "left"
                left.classList.add("column")
                columns.appendChild(left)

                // Right child
                let right = document.createElement("div")
                right.id = "right"
                right.classList.add("column")
                columns.appendChild(right)

                return columns
            })

            let left_gui_id = node.Columns.left
            let new_left_content = convert_to_dom(left_gui_id, vdom)
            let left = dom_node.firstChild;
            let left_content = left.firstChild
            if (left_content == null) {
                left.appendChild(new_left_content)
            } else if (left_content != new_left_content) {
                left_content.replaceWith(new_left_content)
            }

            let right_gui_id = node.Columns.right
            let new_right_content = convert_to_dom(right_gui_id, vdom)
            let right = dom_node.lastChild
            let right_content = right.firstChild
            if (right_content == null) {
                right.appendChild(new_right_content)
            } else if (right_content != new_right_content) {
                right_content.replaceWith(new_right_content)
            }

            return dom_node
        }
        function create_or_update_buttons(gui_id, vdom) {
            let node = vdom[gui_id]
            let dom_node = reuse_or_create(node, () => {
                let button = document.createElement("button")
                button.id = gui_id
                if (node.Button.text) {
                    button.innerHTML = node.Button.text
                } else {
                    button.innerHTML = "Button"
                }
                button.addEventListener ("click", function() {
                    send_event({"Event":{"ButtonPressed":gui_id}})
                });
                return button
            })
            return dom_node
        }
        function create_or_update_checkbox(gui_id, vdom) {
            let node = vdom[gui_id]
            let dom_node = reuse_or_create(node, () => {
                let checkbox = document.createElement("input")
                checkbox.id = gui_id
                checkbox.type = "checkbox"

                if (node.Checkbox.text) {
                    let label = document.createElement("label")
                    label.for = gui_id
                    label.innerHTML = node.Checkbox.text

                    let container = document.createElement("div")
                    container.appendChild(checkbox)
                    container.appendChild(label)

                    return container
                } else {
                    return checkbox
                }
                return container
            })
            return dom_node
        }
        function create_or_update_label(gui_id, vdom) {
            let node = vdom[gui_id]
            let dom_node = reuse_or_create(node, () => {
                let label = document.createElement("div")
                label.id = gui_id
                label.innerHTML = node.Label
                return label
            })
            return dom_node
        }
        function create_or_update_header(gui_id, vdom) {
            let node = vdom[gui_id]
            let dom_node = reuse_or_create(node, () => {
                let header = document.createElement("h1")
                header.id = gui_id
                header.innerHTML = node.Header
                return header
            })
            return dom_node
        }


        function send_event(event) {
            var event = JSON.stringify(event)
            to_server_socket.send(event)
            console.log("Sent event: " + event)
        }
    </script>
    <body>
        
    </body>
</html>